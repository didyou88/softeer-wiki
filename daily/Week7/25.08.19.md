# 1️⃣ 리뷰
**날짜:** 2025.08.19 (화)

### 오늘 작업한 내용

</br>

### 작업에서 배운 내용

#### 1. `CustomPathRepositoryImpl` 쿼리 개선

`searchPathList(PathCondition condition)` 쿼리를 개선하는 작업을 했다.
기존 구현은 `Tuple`을 반환받아 Stream으로 가공하는 방식이었는데, 이렇게 하니

- `Tuple`은 어떤 데이터가 담겨 있는지 직관적으로 알기 어렵고,  
- DTO 변환을 중간 단계에서 별도로 처리해야 했으며,
- 같은 `path_id`를 가진 레코드를 묶기 위해 `Map` + `groupingBy` 과정을 거쳐야 했다.

코드가 장황해지고 DTO가 중간 매개체처럼 늘어나는 느낌이 강했다.  

그래서 QueryDSL의 transform + groupBy 기능을 활용해 구조를 단순화했다.
그리고 `Projections.constructor`를 통해 최종 DTO(`PathDispatchDto`)로 바로 매핑하도록 개선했다.  

```java
.transform(
    groupBy(path.id).list(
        Projections.constructor(
            PathDispatchDto.class,
            path.id,
            car.id,
            list(node)
        )
    )
);
```

이렇게 하니 코드가 훨씬 깔끔해졌고, 
중간 Tuple 처리나 그룹핑 로직을 따로 작성할 필요 없이 QueryDSL 문법에서 바로 원하는 형태로 데이터를 가져올 수 있었다.

상황에 따라 다르겠지만 꼭 필요한 경우가 아니면 혼란을 야기할 수 있는 Tuple 사용을 지양하고,
기왕 사용하는 김에 QeuryDSL의 내장 기능을 많이 활용해봐야겠다.

<br/>

### 어려웠던 점

#### 1. AWS EC2 서버 터짐

아무 작업도 하지 않았는데 EC2 서버가 갑자기 다운되는 문제가 반복적으로 발생했다.
이전에는 서버가 다운되더라도 GitHub Actions의 CD 파이프라인을 다시 실행하면 정상적으로 구동되곤 했는데, 이번에는 재배포로도 해결되지 않았다.

우선 문제 원인을 파악하기 위해 애플리케이션 로그를 따로 저장하는 스크립트를 추가했다.
하지만 로그에는 API 호출 기록이나 단순 Info 로그만 남아 있어 원인 흔적은 보이지 않았다.
애플리케이션 실행중 로직이 문제라고 생각했는데 아니었다.

그다음으로 EC2에서 제공하는 System Log를 확인했다. 그 결과, OOM 발생으로 인해 커널이 실행 중인 프로세스를 순차적으로 정리하는 과정에서 최종적으로 `jar` 실행 파일이 강제 종료된 것을 확인할 수 있었다.  

추가 분석을 통해 원인을 좁혀보니, 사용 중인 EC2 인스턴스의 RAM 용량이 1GB에 불과했고, 기본적으로 swap 기능이 설정되어 있지 않았다.

Swap 설정 후 서버는 더 이상 다운되지 않았고, 안정적으로 동작했다.
이전에 프리 티어 인스턴스를 여러 차례 사용했을 때는 이런 문제가 발생하지 않아, 메모리 이슈를 미처 고려하지 못한 점이 아쉬웠다.
문제를 "애플리케이션 버그"로만 한정 지어 생각하면 원인을 찾기 어려운 것 같다.
운영 환경의 인프라 제약 조건(리소스 한계) 역시 주요한 장애 요인이라는 점을 체감했다.
단순히 코드와 로직이 아니라, 낮은 레벨에서도 자원을 어떻게 관리할지까지 고려하는 습관을 길러야 겠다고 느꼈다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 네이밍에서 시간 소요가 많음

ERD나 클래스 다이어그램을 설계할 때 변수명과 클래스명이 길어지는 게 싫어서 짧은 단어를 사용했다.
하지만 개발이 진행되면서 더 적합한 상황에서 이미 사용된 단어를 다시 쓰지 못하는 문제가 발생했다.
이미 여러 곳에서 사용된 네이밍을 변경하기 어려워, 대체 이름을 고민하느라 불필요하게 많은 시간을 소모했다.

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 의미 전달이 가장 중요

- 변수/클래스명이 다소 길더라도 **직관적이고 명확한 의미 전달**을 우선시할 것
- 프로젝트 규모가 커질수록 네이밍 충돌 가능성이 커지므로, 단순히 당시 상황만 보고 짧게 짓지 않기.
- 사용 범위와 맥락을 고려해 장기적으로도 유지보수하기 좋은 네이밍을 선택하기.  
- "짧게 쓰기"보다 "명확하게 쓰기"를 습관화하기.  
- 다음 부터는 이러지 말아야지...

<br/>

#  3️⃣ 학습 내용 정리

## Swap 

- 물리적 메모리가 부족할 때, 디스크 일부 공간을 메모리처럼 사용하는 기능  
- 부족한 RAM을 보완해 OOM으로 인한 프로세스 종료를 완화
- 현재 EC2 디스크는 8GB, 이 중 일부를 swap으로 할당해 문제 해결

## Stream vs Transform 비교

### Transform 방식 (QueryDSL transform().groupBy())

| 구분     | 설명                                                                                                    |
| ------ | ----------------------------------------------------------------------------------------------------- |
| **특징** | - DB 조회 시점에서 그룹화<br>- SQL 결과를 Tuple 단위로 가져온 뒤, QueryDSL이 내부적으로 메모리에서 groupBy 처리                       |
| **장점** | - 코드가 깔끔하고 DTO로 바로 매핑 가능<br>- Tuple → Map → DTO 변환 과정 불필요<br>- groupBy 최적화 덕분에 일반적인 규모의 데이터에서는 성능이 좋음 |
| **단점** | - QueryDSL 내부적으로 groupingBy 사용 → 대량 데이터에서 메모리 사용 부담<br>- 매우 큰 dataset 처리 시 transform 내부 비용 발생 가능      |


### Stream 방식 (Java Stream API)

| 구분     | 설명                                                                                                         |
| ------ | ---------------------------------------------------------------------------------------------------------- |
| **특징** | - DB 조회 후 Java 메모리에서 그룹화<br>- QueryDSL 종속적이지 않고, 순수 자바 방식                                                  |
| **장점** | - QueryDSL에 종속되지 않음 → 재사용성과 유연성 높음<br>- Stream API로 다양한 후처리 가능 (map/filter 등 조합 용이)                        |
| **단점** | - 조회한 Tuple 전체를 메모리에 올려야 함 → 대량 데이터에서 부담<br>- map → groupBy → collect 반복으로 transform 대비 코드 길어지고 약간 느릴 수 있음 |


결론: 일반적인 경로/노드 조회에는 **Transform**이 더 직관적이고 효율적. 다만 복잡한 후처리가 필요한 경우엔 **Stream** 방식이 더 유연하다.

<br/>
