# 1️⃣ 리뷰
**날짜:** 2025.08.21 (목)

### 오늘 작업한 내용
- [x] 좌표 정보 API 개발 (마커, 경로)
    - [x] marker: 예약자 이름 추가
    - [x] highlight
    - [x] 테스트 데이터 삽입
- [x] path dev 배포
- [ ] 기존 경로 배차 로직 테스트
    - [ ] 스트림 형식으로 리팩토링
    - [x] 데이터 저장을 위한 추상화 진행
    - [ ] 데이터 저장 테스트 (-ing)
    - [ ] 오류 검출
 

</br>

###
작업에서 배운 내용

#### 1. cascade = CascadeType.ALL

```java
@OneToOne(mappedBy = "endNode", cascade = CascadeType.ALL)
```
JPA의 cascade 옵션을 적극적으로 활용하면 연관된 엔티티 관리가 훨씬 간편해진다.

node, segment, point는 계층적으로 연결되어 있다.
node가 있어야 segment가 존재하고,
segment가 있어야 point가 존재한다.

즉, 상위 엔티티가 삭제될 경우 하위 엔티티들도 자연스럽게 함께 삭제되어야 한다.
기존에는 삽입,삭제 시 연관된 엔티티 레포를 일일이 호출해야 했는데, cascade = CascadeType.ALL을 사용하면 상위 엔티티 조작만으로 관련된 모든 엔티티에 변경 사항이 전파된다.

이번에 적용하면서, 엔티티 생명주기 관리에 대한 JPA 적용법을 알 수 있었다.

<br/>

### 어려웠던 점

#### 1. 쿼리가 복잡하면 ERD 구조가 잘못되지 않았는지 확인하자

지도 데이터는 크게 세 가지 역할을 가진다.
- marker: 경유 지점
- polyline: 실제 경로를 그리기 위한 조밀한 좌표 리스트
- highlight: 예약별 탑승지 ~ 시작지까지의 segment 정보

문제는 book, path, node, segment, point 테이블이 얽히면서 연관 관계가 지나치게 복잡해졌다는 것이다.
프런트엔드에서 지도 API를 호출할 때 여러 번 통신하는 대신 한 번에 데이터를 제공하려고 하다 보니 쿼리도 점점 지저분해졌다.

그 과정에서 에러 발생 시 유지보수 난이도도 높아졌고, 코드 가독성도 떨어져서 동료가 이해하기 어려운 코드가 됐다.

유진님이 "이럴 땐 ERD 설계에 문제가 있을 수 있다"는 피드백을 줬고, 실제로 구조상 문제가 있었다.

예를 들어, node 테이블의 타입은 CENTER, START, END인데, START/END 노드는 항상 자신을 기점으로 왼쪽에 segment를 가지고 있었다.
따라서 segment 테이블이 node_id 두 개(FK)를 가질 필요가 없었는데, 그렇게 설계되어 있어서 쿼리가 불필요하게 복잡해진 상태였다.

결국 문제는 SQL이 아니라 ERD에서 비롯된 것이었다.


<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 주어진 자원 내에서 최선을 다하기

지금 문제는 ERD를 건들 수 있는 상황이어서 비교적 간단하게 문제를 해결할 수 있었지만, 그렇지 않은 경우가 허다하다.
그런 경우엔 주어진 자원내에서 최선의 방법을 찾아가야 한다고 생각한다.
비록 쿼리 최적화가 답은 아니었지만, 그 과정에서 어떻게하면 최소 DB 연결로 필요한 데이터를 불러 올 수 있을지 고민을 많이 할 수 있었다.

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 더 효율적인 방법 탐구 부족

아는 범위 안에서만 해결책을 찾으려는 습관 때문에 시간을 많이 허비했다.
쿼리 최적화에만 매달렸는데, 사실은 ERD를 조금만 수정해도 쉽게 풀리는 문제였다.

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 시도를 코드 레벨에서만 멈추지 않기

앞으로는 문제를 해결할 때 "현재 내가 집중하는 단위가 맞는가?"를 먼저 점검해야겠다.
코드 → 쿼리 → ERD → 도메인 설계처럼 단계별로 범위를 넓히면서 원인을 살펴보는 습관을 들여야겠다.

<br/>

#  3️⃣ 학습 내용 정리

## CascadeType.ALL
상위 엔티티의 생명주기 변화가 하위 엔티티까지 전파된다.  
→ 삽입, 삭제 시 연관된 엔티티 레포를 직접 호출하지 않아도 됨.

<br/>
