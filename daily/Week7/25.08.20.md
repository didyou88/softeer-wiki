# 1️⃣ 리뷰
**날짜:** 2025.08.20 (수)

### 오늘 작업한 내용
- [x] PR 리뷰
- [ ] 지도 그리기 정보 API 개발
  - [ ] marker
  - [x] polyline
  - [x] highligh
- [ ] 기존 경로 배차 로직 테스트  
 

</br>

### 작업에서 배운 내용

#### 1. QueryProjection

지도 그리기 API를 개발하면서 **QueryDSL에서 Projection을 다루는 여러 방식**을 찾아보게 되었다.
여러 테이블에서 데이터를 조합해 리스트를 만들어야 했기 때문에, 모든 필드를 직접 써줘야 하는 constructor 방식 말고 더 효율적인 방법이 있을지 고민했다.

그러다 유진님이 작성하신 코드에서 `@QueryProjection`을 활용한 방식을 발견했다.
`@QueryProjection`은 DTO 클래스에 직접 어노테이션을 붙여 컴파일 시점에 오류를 잡아낼 수 있다는 장점이 있었다.

나는 그동안 단순하고 직관적이어서 흐름을 한눈에 파악하기 좋은 **constructor 기반 생성자 주입**을 주로 사용해왔다.

그렇다면 어떤 방식을 쓰는 것이 적절할까?  
- **Constructor 방식**은 단순한 DTO 변환에 적합하고, 외부 라이브러리 의존을 최소화할 수 있다.
- **QueryProjection 방식**은 타입 안정성과 가독성이 중요한 상황에서 유용하다.

우리 서비스는 DTO를 `record`로 관리하고 Builder 패턴도 사용하기 때문에, `QueryProjection`을 적용했을 때 Builder와 충돌이 발생했다.
결국 모든 필드를 직접 써줘야 하긴 하지만, 복잡한 데이터를 다루는 만큼 쿼리에서 필요한 필드를 명시적으로 드러내는 편이 휴먼 에러를 줄일 수 있다고 판단했다.
그래서 이번에는 생성자 기반 Projection을 선택했다.  

다만 특정 쿼리에서 타입 안정성이 특히 중요한 경우라면, `QueryProjection`을 도입하는 것도 충분히 고려할 만하다.

익숙한 방법이든 새로운 방법이든, 결국 서비스 구조와 팀 환경에 맞는 방식을 선택하는 게 가장 효율적인 것 같다.

<br/>

### 어려웠던 점

#### Record와 Nested Projection

Segment 조회 API를 구현하면서 `record`와 `nested projection` 매핑을 하며 에러 상황을 겪었다.
`SegmentDto` 안에 `List<LatLng>`를 넣고 싶었지만, 단순 `Projections.constructor()`로는 해결되지 않았다.
여기에 `segment` 한 건에 여러 `point`가 조인되면서 row가 N개로 늘어났는데, 엔티티에 `List<Point> points`가 있으니 쿼리 결과에서도 자동으로 컬렉션이 묶일 것이라고 착각하고`.fetchOne()`을 사용해버렸다.
결국 다중 row에 단일 결과를 강제하면서 `NonUniqueResultException`이 터졌다.

record는 생성자 기반 바인딩만 지원하는데, 나는 그 특성을 제대로 이해하지 못하고 nested projection을 억지로 record 생성자에 넣으려고 했다.
그리고 “왜 이 방식이 구조적으로 불가능한가”를 개념으로 점검하기보다, 코드 레벨에서만 해결을 시도했다.

타입 안정성을 기대하며 Projection으로 끝내보려 했지만, 결론적으로는 초기 접근으로 돌아갔다.
쿼리 결과를 `Tuple`로 받아 필요한 필드를 직접 꺼내고, `LatLng` 리스트를 수동으로 조립해 `SegmentDto`(record) 생성자에 전달하는 방식으로 정리했다. 

오류를 길게 붙잡고 있었던 이유는 “레코드와 프로젝션의 특성을 제대로 이해하지 못한 채” 억지로 해결하려 했기 때문이다.
쿼리 단에서 오류 파악이 잘 안 된다면 쿼리 결과의 모양을 먼저 그려보고, 지금 쓰고 있는 QueryDSL 문법이 제대로 이 모양을 지원하고 있는지 따져봐야 겠다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 효율적인 방식을 고민하는 습관

효율적인 방식을 찾으려는 고민 덕분에 여러 시도를 해보았고, 그 과정에서 에러도 경험하며 결국 초기 상태로 돌아가기도 했다.
하지만 이 과정이 헛된 것은 아니었다. 기술을 선택하는 나만의 기준이 조금씩 쌓이고 있다는 것을 느꼈다.
오늘 당장 적용하지 못한 방법이라도, 찾아보고 부딪혀본 경험이 다음에는 더 빠른 선택으로 이어질 기반이 되어 주었으면 좋겠다.

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 중단 시점을 놓쳤다

안 되는 방향임을 인지했음에도 끝까지 적용해보려다 시간을 과하게 소모했다.  
원래는 기존 경로 배차 테스트까지 마무리하는 게 목표였지만, Projection 시도를 붙잡고 늘어지다 보니 계획에 차질이 생겼다.  

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 중단 지점을 명확히 설정하기

오늘 멈췄어야 할 순간은 Tuple → Projection 전환 과정에서 Record는 nested 지원이 불가능하다는 사실을 확인했을 때였다.
그럼에도 우회 방법을 끝까지 찾으려 했고, 결국 다시 Tuple로 되돌아오면서 불필요한 반복을 만들었다.

앞으로는 개선 방향을 이렇게 잡아보려고 한다.
- 기술 제약이 명확히 드러나는 순간: 억지 시도는 접고, 당장 목표 기능을 안정적으로 완성하는 방향으로 선회한다.  
- 중단 기준 설정: “n시간 내에 해결책이 안 보이면 기존 방식으로 되돌아간다”는 식으로 제한 시간을 둔다.
- 실험과 실무를 분리: 내가 지금 실험을 하고 있는건지 실무 작업을 해야하는건지 의식적으로 구분하자.

여러 시도에 대한 집착은 성장의 원동력이 될 수도 있지만, 정작 중요한 곳에 소모해야할 집중력을 갉아먹기도 한다

<br/>

#  3️⃣ 학습 내용 정리

## Nested Projection

- QueryDSL은 기본적으로 단일 row → 단일 DTO 매핑만 지원한다.  
- DTO 내부에 `List` 같은 중첩 컬렉션 필드를 바로 매핑하려 하면 오류가 발생한다.  
- 특히 `record`는 생성자 기반 바인딩만 지원하기 때문에, nested projection을 생성자에 직접 넣는 방식은 불가능하다.  
- 이럴 때는  
  - `groupBy` + `list()` 조합을 쓰거나  
  - `Tuple`로 조회 후 컬렉션을 직접 조립하는 방식으로 해결해야 한다.  

<br/>
