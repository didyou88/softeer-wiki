# 1️⃣ 리뷰
**날짜:** 2025.07.23 (수)

### 오늘 작업한 내용
- [x] FE/BE 회의
- [x] 디자인/개발 회의
- [x] 기획/디자인/개발 회의
- [ ] W3-7 과제
  - [ ] 동적 템플릿 엔진 기능 추가
  - [ ] 코드 구조 리팩토링 

</br>

### 작업에서 배운 내용

#### 1. 상수를 관리해보자!

동적 템플릿을 생성하면서 로그인 여부에 따라 화면을 다르게 렌더링해야 한다. (나의 병목 지점..)
프론트엔드 경험이 전혀 없지는 않아서 자꾸만 html 파일에서 script를 사용하는 방식으로 해결하려는 쪽으로 흘러갔지만,
서버 사이드 렌더링에 도전해보고 싶어서 직접 템플릿 엔진을 만들어보기로 했다.

처음에는 동적으로 바뀌는 부분들을 String 타입의 상수로 선언하고, 이를 enum으로 관리해 키워드 기반으로 불러오는 방식을 사용했다.
그러다 상수를 관리하는 방식에는 enum 외에도 static final이라는 선택지가 있다는 것이 생각났다.
그렇다면, enum과 static final은 언제 어떤 상황에서 써야 할까?

결론적으로, 이번 작업에서는 static final로 관리하는 것이 더 적합했다.
원래는 enum을 활용해 switch 구문으로 경로에 따라 값을 가져오려 했지만,
작업 자체는 단순히 미리 만들어둔 HTML 문자열을 불러오는 것이었기 때문에,
상수가 String Constant Pool에 저장되어 재사용되고, 객체 참조 없이 바로 접근 가능한 static final이 성능 측면에서 훨씬 유리했다.

```java
public static final String LOGIN = "login에 대한 HTML 문자열";
```

같은 상수라도 사용 맥락에 따라 어떤 방식이 더 효율적인지는 달라질 수 있다.
앞으로도 기술을 선택할 때는 단순히 "쓸 수 있다"보다 "왜 이걸 써야 하는가?"를 기준으로 판단하고 적용해 나가야겠다.

<br/>

### 어려웠던 점

#### 1. 다른 직군과 "align" 하기

프런트엔드/백엔드, 디자인/개발, 디자인/기획/개발 등 다양한 조합으로 총 세 차례 회의를 진행했다. 그런데 회의마다 서로 알고 있는 내용이나 방향성이 조금씩 달라, 같은 주제를 놓고도 다르게 이해하고 있는 경우가 종종 있었다.

회의 시간을 효율적으로 사용하기 위해 사전에 백엔드의 방향성을 정리해 준비해 갔지만, 실제로는 팀 전체의 방향과 어긋나거나 핀트가 맞지 않아 새로운 방식으로 다시 고민해야 했던 상황이 반복되었다.

평소 문서화도 잘 하고 소통도 원활하다고 생각했지만, 실상은 용어에 대한 인식 차이에서 발생한 오해가 이런 상황을 유발하고 있다는걸 알게 되었다. 예를 들어, "실시간 예약"이라는 표현을 두고 디자인팀은 '예약과 동시에 배차까지 실시간으로 안내되는 시스템'으로 이해한 반면, 기획 및 개발팀은 '예약과 배차는 실시간으로 진행하되, 실제 안내는 운행 전날 제공되는 방식'으로 인식하고 있었다.

이처럼 중요한 기능에 대해 각 직군 간 해석이 달랐고, 용어 하나의 미묘한 차이가 큰 혼선을 야기할 수 있다는 점을 깨달았다.
협업에서는 개념 정리를 통해 팀에서 사용하는 단어의 의미를 명확히 공유하는 것이 갈등을 줄이고 효율적인 작업 진행을 위해 정말 중요하다는 것을 배운 시간이었다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 아이디어를 적극적으로 제시하기

프로젝트 초반에는 기획자가 아님에도 아이디어를 자주 제시하는 것이 혹시 월권이 아닐까 걱정이 되었다.
하지만 기획/디자인 팀으로 부터 '특정 문제에 깊이 몰입하다 보니, 때때로 한 방향에 매몰되는 경우가 있었는데,
그럴 때 개발자의 시각에서 새로운 관점을 제시해주는 것이 오히려 도움이 되었다'는 피드백을 받았다.

예를 들어, 자동 배차 알고리즘에 대해 논의할 때, 어르신들이 차량을 타고 병원까지 가야 하는 경우
대체로 예약이 필요한 병원이 많고, 예약 시간까지 도착해야 한다는 점을 짚어주며 고려 요소를 보완할 수 있었다.

비록 모든 아이디어가 반영되는 것은 아니더라도, 개발자로서 문제를 함께 고민하고 의견을 제시하는 태도는 앞으로도 계속 유지해야 할 점이라고 생각한다.

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 꼬리에 꼬리를 무는 질문의 부족

오늘 수업 시간에 상태 관리에 대한 토론을 진행했다.
그 과정에서 "JWT를 왜 써야 하는가?"라는 질문이 나왔고, 다른 팀들이 깊이 있는 논의를 이어가는 모습을 보며, 스스로는 그만큼 깊게 고민하지 못했다는 것을 깨달았다.
이유를 파고들고 거기서 또 다른 질문으로 확장해 나가는 사고의 깊이가 부족한 것 같는 생각이 들었다.

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 모호함이 느껴지면 "왜?"를 던져보자

CS의 세계는 하드웨어, 네트워크, 프레임워크 등 다양한 분야가 유기적으로 연결되어 있다.
따라서 '왜 이 기술을 써야 하는가?'라는 질문은 개발자로서 계속 던져야 할 중요한 질문이라고 생각한다.

하지만 나는 누군가 "이건 이렇다"고 말하면, 깊이 따져보기보다 "아 그렇구나" 하고 쉽게 수용하는 편이다.
수용도 장점이지만, 모호함이 남아 불편함이 느껴지는 순간에는 그걸 그냥 넘기지 말고 해소하려는 노력이 필요하다고 느꼈다.

저번 Problem에서도 정확히 이해하지 못한 질문을 그냥 수긍하는 태도를 보였다고 적었는데, 이런 태도가 나의 사고의 깊이를 얕게 만들고 있다는 걸 느꼈다. 
앞으로는 작은 의문이라도 "왜?"를 스스로에게 던지며 이해의 폭을 넓혀가려고 노력해야겠다!!

> 이 문제에 대한 Try는 반드시 이번 부트캠프 동안 Keep으로 넘겨보자 (다짐)

<br/>

#  3️⃣ 학습 내용 정리

## `enum` VS `static final`

항목 | public static final | enum 상수
-- | -- | --
메모리 사용 | SCP에 저장되어 재사용 가능오버헤드 거의 없음 | 메타데이터 + 객체 인스턴스 + 내부 필드 등상대적으로 메모리 많이 사용
접근 방식 | 직접 메모리 참조 (TEST) | 객체를 통한 간접 접근 (TEST.getValue())
성능 | 빠름, 컴파일 타임 최적화 가능 | 상대적으로 느림 (메서드 호출 포함)
타입 안전성 | 낮음 (오타 발생 시 런타임 오류) | 높음 (컴파일 타임에 체크 가능)
기능 확장성 | 불가능 (단순 값만 보유) | 가능 (필드, 메서드, 인터페이스 구현 등)
그룹화 용이성 | 불편 (관련 상수를 따로 관리해야 함) | enum 타입으로 상수 그룹화 쉬움
switch 사용 | 문자열 switch 시 Java 7 이상에서 가능 | switch 구문과 자연스럽게 호환

<br/>
