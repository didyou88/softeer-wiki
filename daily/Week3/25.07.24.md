# 1️⃣ 리뷰
**날짜:** 2025.07.24 (목)

### 오늘 작업한 내용
- [x] 종합 프로젝트 자동 배차 기능 회의
- [ ] W3-7 과제
  - [ ] 동적 템플릿 엔진 기능 추가
  - [ ] 코드 구조 리팩토링 

</br>

### 작업에서 배운 내용

#### 1. Object를 Map의 키로 사용할 때 주의할 점

API를 편리하게 등록하고 검색하기 위해, 기존의 이중 Map 구조를 개선해 `ApiKey`라는 클래스를 키로 사용하도록 했다.
하지만 실제로 적용해보니, 분명히 넣었던 키를 다시 조회할 수 없는 문제가 발생했다.
조사해보니 Object 타입을 키로 사용할 경우, `equals()`와 `hashCode()`를 반드시 오버라이드해야 한다는 것을 놓치고 있었다.

Java의 HashMap은 내부적으로 다음과 같은 방식으로 동작한다.
| 메서드          | 역할                                |
| ------------ | --------------------------------- |
| `hashCode()` | **버킷 위치 계산** – 객체의 주소를 반환 |
| `equals()`   | **버킷 내 실제 키 비교** – 주솟값을 통해 객체가 같은지 비교해주는 메소드 |

즉, 두 객체가 같은 값을 가지고 있더라도, equals()와 hashCode()가 제대로 구현되어 있지 않으면 HashMap은 서로 다른 키로 인식한다.
예를 들어, "GET"과 "/user"를 가진 ApiKey 인스턴스 두 개가 있다고 하더라도 기본 Object의 equals()는 주솟값(참조 값)을 비교하기 때문에 다르다고 판단한다.
따라서 사용자 정의 클래스가 Map의 키로 쓰이려면, 논리적으로 동등한 객체가 같은 해시값을 가지도록 equals()와 hashCode()를 구현해야 한다.

생각한 방식으로 코드가 작동하려면 자료구조가 실제 코드에서 작동하는 원리를 이해하는 것이 우선이라는 것을 새삼 깨달았다.

<br/>

### 어려웠던 점

#### 1. API 관리 구조 변경

api를 이렇게 관리하는 게 정말 효율적일까?
```java
private static final Map<String, Map<String, ApiResolver>> apiMap = new HashMap<>();
```
이 구조는 path로 한 번, method로 한 번 더 검색해야 해서 비효율적이라고 느꼈다.

대안으로 두 가지를 고민했다.

1. 저장 방식을 개선해서 자료구조 자체를 바꾸기
2. URL을 도메인 단위로 쪼개서 관리하기  
예: `/user/create`, `/user/login`처럼 구조화된 URL을 기반으로 `/user`와 `/create`, `/login`을 분리 저장

2번 방법은 url을 작성할 때 정책을 미리 정해야할 뿐더러 url이 복잡해지면 관리가 힘들 것 같아서 첫 번째 방식으로 변경하기로 했다.
Map<ApiKey, ApiResolver> 구조를 도입해서, URL과 method를 합쳐 하나의 키로 사용했다.
```java
public class ApiKey {
    private final String path;
    private final String method;

    public ApiKey(String method, String path) {
        this.path = path;
        this.method = method;
    }
}
```

API 관리 로직은 처음에 단순하게 출발해도, 결국엔 의도를 분명히 하는 구조가 더 좋다고 느꼈다.
객체 기반으로 명확하게 표현하는 게 유지보수에도 나은 것 같다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 규칙적인 생활 습관

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 시각화 도구 활용 능력이 부족한 것 같다

클래스 다이어그램이나 플로우 차트처럼 텍스트로 정리한 내용을 도식화하는 데 시간이 오래 걸리는 편이다.
배치나 정렬에 신경을 많이 쓰다 보니, 실제로 필요한 상황임에도 작업을 미루거나 마음먹고 해야 겨우 시작하는 경우가 많았다.

하지만 요즘은 이러한 과정을 자동화해주는 도구들이 많이 있다는 걸 알게 됐다.
업무 효율을 높이기 위해서라도, 이런 도구들에 대한 적극적인 탐색과 활용이 필요하다고 느꼈다.

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 부트캠프에서 알게 된 툴들을 중심으로 자동화 도구를 적극적으로 탐색하자

오늘 유진님께서 추천해주신 툴이 인상 깊었다.
노션에 정리한 배차 알고리즘을 빠르게 도식화하신 걸 보고 어떻게 했는지 여쭤봤더니,
ChatGPT에서 글로 내용을 설명한 뒤 mermaid 코드로 변환하면 자동으로 다이어그램 생성된다고 알려주셨다.
그리고 제미나이에 현재 디렉토리 구조를 보고 클래스 다이어그램을 그려달라고 요청하면 자동으로 생성된다는 것도 알려주셨다.

이러한 도구들을 효율적으로 사용하면 작업 시간을 크게 줄일 수 있을 것 같다. (물론 이해를 잘 하고 써야겠지만!)
앞으로는 도식화나 반복 작업을 수작업으로 하기보다 나에게 도움되는 방향으로 자동화 가능한 부분은 도구를 활용해 시간을 아껴보자!

<br/>

#  3️⃣ 학습 내용 정리

## FunctinalInterface

#### 1) 정의
- 하나의 추상 메서드만 가지는 인터페이스
- Java에서 함수를 변수처럼 다루고 싶을 때 사용
- 보통 람다(lambda) 와 함께 사용
  
#### 2) 예시
```java
MyFunction f = x -> x * 2;
System.out.println(f.apply(3)); // 출력: 6
```
- Java 내장 함수형 인터페이스
  - Function<T, R> → R apply(T t)
  - Consumer<T> → void accept(T t)

#### 3) 언제 lambda를 쓰면 좋을까?
| 조건                           | 람다 사용 가능? | 이유            |
| ---------------------------- | --------- | ------------- |
| 로직이 간단하고 길지 않다               | 사용해도 좋음 | 선언이 빠르고 직관적임  |
| 외부 의존성이 많다 (Util, Handler 등) | 별도 클래스로 | 테스트/유지보수에 유리함 |
| 재사용되거나 확장 가능성이 있다            | 별도 클래스로 | 구조적 확장에 더 적합함 |

<br/>
