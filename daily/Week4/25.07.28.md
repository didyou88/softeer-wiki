# 1️⃣ 리뷰
**날짜:** 2025.07.28 (월)

### 오늘 작업한 내용
- [x] BE 환경 세팅
  - [x] Springboot 패키지 설정
  - [x] 폴더 구조 맞추기
  - [x] BaseResposne, ErrorCode FE와 협의
  - [x] Swagger 설치
- [x] 협업 도구 세팅
  - [x] Git Project 세팅
  - [x] 템플릿 양식 맞추기 (issue, pr)
  - [x] 코드 컨벤션 맞추기 (commit message, git branch 전략 등)

</br>

### 작업에서 배운 내용

#### 1. Global Exception Handler

예전부터 익숙하게 아래처럼 컨트롤러 메서드 안에서 try-catch로 예외를 처리해왔다.
```java
public BaseResponse<String> adminController() {
    try {
        return new BaseResponse<>("success");
    } catch (BusinessException e) {
        return new BaseResponse<>(e.getErrorCode());
    }
}
````
하지만 이 방식은 컨트롤러마다 같은 `try-catch` 블록이 반복되면서 코드가 길어지고 새로운 예외를 추가하거나 처리 방식을 바꾸고 싶을 때, 모든 컨트롤러를 찾아다니며 수정해야 하는 번거로움이 있었다.

그러다 팀원과의 코드 리뷰 중에 `@RestControllerAdvice` + `@ExceptionHandler` 조합을 알게 되었다.
```java
@Hidden
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<BaseResponse<?>> handleBusinessException(BusinessException e) {
        return ResponseEntity
                .status(HttpStatus.OK)
                .body(BaseResponse.fail(e.getErrorCode()));
    }
}
```
이 구조로 바꾸니 예외 처리 로직이 한 곳에 모이면서 컨트롤러는 본연의 역할인 요청 처리에만 집중할 수 있게 되었고,
모든 API가 동일한 응답 포맷을 유지하게 됐다.

다만 주의할 점은, 예외 처리 우선순위를 잘못 설정하면 의도치 않게 상위 예외 핸들러가 하위 예외를 잡아버릴 수 있다.
그리고 처리하지 않은 예외는 그대로 전파되므로 예상 가능한 예외를 빠짐없이 등록해야 한다.

예외 처리 방식 하나를 바꿨을 뿐인데, 코드의 일관성과 유지보수성이 눈에 띄게 좋아졌다.
앞으로는 기능 개발만큼이나, 예외 처리 구조 설계에도 시간을 투자해야겠다고 느꼈다.
<br/>

### 어려웠던 점

#### 1. Swagger와 `@RestControllerAdvice` 간의 충돌

이번 작업에서 가장 예상치 못한 문제 중 하나는 Swagger와 `@RestControllerAdvice` 간의 충돌이었다. 

```java
java.lang.NoSuchMethodError: 'void org.springframework.web.method.ControllerAdviceBean.<init>(java.lang.Object)'
```
문제 원인을 찾아보니, StringBoot가 "문법을 바꿨는데", Swagger는 "옛날 문법"을 쓰고 있어서 충돌이 난 것이었다.
SpringBoot에선 `ControllerAdviceBean`이라는 내부 클래스의 메서드 시그니처가 바뀌었지만,
Swagger는 옛날 방식으로 생성자를 호출하려고 하다 `NoSuchMethodError`에러를 낸 것이었다.

이 문제를 해결하기 위해 Swagger의 `@Hidden` 애노테이션을 적용했다.  
원래 `@Hidden`은 Swagger에서 특정 컨트롤러나 API를 숨기는 용도로 사용되는데, 이번 경우엔 `GlobalExceptionHandler`를 Swagger 스캔 대상에서 제외하기 위해 사용했다.

해결 과정에서 깨달은 점이 있다.
나는 `@Hidden`이 Swagger 문서에만 영향을 주는 단순한 표시 정도라고만 생각했는데, 실제로는 스캔 프로세스에도 관여하여 충돌을 방지하는 데 활용될 수 있었다.
이번 경험 덕분에 애노테이션 하나를 '그냥 쓰는 것'과 '이해하고 쓰는 것'의 차이는 크다는 것을 깨달았다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 익숙한 방식보다 더 나은 방법을 선택했다
유진님과 환경 세팅을 하면서 디렉토리 구성, 예외 처리, DTO 생성 방식 등을 맞춰가는 과정에서, 서로 사용하던 방식이 많이 달랐다.
그럴 때마다 내가 익숙한 방식만을 고집하기보다는, 어떤 방식이 이번 프로젝트에 더 잘 맞을지를 기준으로 선택했다.
그러다 서로의 방식을 적절히 섞어 새로운 제3의 방식을 만들어낸 점도 재밌었다.

기존에는 빠르게 개발하려는 마음에 익숙한 방식만 고수하곤 했지만,
이번 webserver 구현을 하면서는 다른 사람의 코드를 참고하고,
내 코드도 주체적으로 리팩토링하면서 기술에 대한 수용력이 확실히 늘었다는 걸 느꼈다.
앞으로도 이런 태도를 계속 유지해야겠다!

<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 공지를 제대로 확인하지 않았다

Woon이 슬랙에 오늘의 시간표와 자리 배정을 안내해주셨는데, 내용을 제대로 확인하지 않고 자리에 앉았다.
Woon이 알려주셔서 다시 제자리를 찾아갔다.

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 중요한 슬랙 공지는 집중해서 확인하자
사람이 많은 상황에서는 작은 실수 하나도 누군가에게 반복적으로 설명하거나 바로잡아야 할 일이 될 수 있다.
내가 한 번 집중해서 공지를 정확히 읽기만 해도, 리더나 동료들의 수고를 덜 수 있다.
팔로워의 입장에서 사소한 주의가 팀 누군가의 수고를 줄 수 있다는 걸 기억하자.

<br/>

#  3️⃣ 학습 내용 정리


## 1. 서버 배포 방식 비교

| 구분 | 방식 | 장점 | 단점 |
|------|------|------|------|
| **통합 배포** | 프런트 빌드 결과를 `resources/static`에 포함해 Spring Boot 서버와 함께 배포 | - 설정이 단순<br>- 배포 과정이 한 번에 끝남 | - 프런트 수정 시 백엔드까지 재배포 필요<br>- 빌드 속도 증가 |
| **분리 배포** | 백엔드는 EC2에, 프런트는 S3에 각각 배포 | - 서비스 영역 명확히 분리<br>- 프런트 수정 시 백엔드 영향 없음<br>- 확장성 높음 | - 초기 설정 복잡<br>- 배포 파이프라인 2개 구성 필요 |

- 우리팀이 선택한 방식 : **분리 배포**
- 우리팀 상황 :
  - FE와 BE를 같은 레포에서 관리하는 모노레포 구조
  - `dev` 브랜치 아래에 `dev-be`, `dev-fe` 브랜치를 따로 두고, 각 기능 개발이 끝나면 `dev`로 병합한 뒤 배포하는 방식
- 장점 : 독립 배포 가능
  - 프런트와 백엔드가 각각의 배포 파이프라인을 가지므로, 한쪽 변경이 다른 쪽의 재배포를 강제하지 않는다.   
  - 예를 들어 프런트 UI 수정이 있을 때, 백엔드 서버를 재시작할 필요가 없다

<br/>
