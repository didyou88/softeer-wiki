# 1️⃣ 리뷰
**날짜:** 2025.07.17 (목)

### 오늘 작업한 내용

- [X] W2-S4 PR 올리기
- [ ] W2-S5 과제 수행
    - [X] 로그인 후 리다이렉션
    - [ ] 세션, 쿠키 객체 생성
    - [X] 로그인 사용자 입력값 validation
    - [ ] 로그인 실패 알림
- [X] 5조 개발 회의

<br/>

### 작업에서 배운 내용

#### 1. ApiHandler 인터페이스를 제네릭 타입으로 변경

로그인 기능을 구현하면서 `ApiHandler` 인터페이스의 반환 타입을 고정할 수 없다는 점을 깨달았다.
회원가입 API에서는 반환할 값이 없기 때문에 `void` 타입으로도 충분했지만, 로그인 API는 사용자 정보를 반환해야 했다.
이러한 상황에 대응하기 위해 `ApiHandler<T>` 형태로 인터페이스를 제네릭 타입으로 변경했다.

추가로, API 처리 흐름상 `ApiResolver`에서 DB 결과를 바탕으로 `HttpResponse`를 생성하는 과정에서 필수값 누락이나 예외 상황도 함께 처리해야 한다는 점을 인식하게 됐다. 
이후 리팩토링 과정에서 `Resolver` 계층에서도 예외 처리를 강화하고, `HttpStatus`에 맞는 응답을 생성하는 로직으로 개선해봐야겠다.

#### 2. 멀티 스레드 환경에 대한 간과

그룹 세션에서 `ConcurrentHashMap`을 사용하는 재현님의 코드를 보고 현재 개발 중인 서버가 멀티스레드 환경에서 실행된다는 점을 상기하게 되었다.
HTTP 서버는 다수의 클라이언트 요청을 동시에 처리해야 하기 때문에, 모든 공유 자원은 동시성 문제를 고려해 설계해야 한다.
내 코드 역시 클라이언트의 요청마다 새로운 스레드가 할당되는 구조인데, 요청이 많아질 경우 정상적으로 작동하지 않을 여지가 있다는 점을 간과하고 있었다.

현재는 회원가입과 로그인 같은 등록, 읽기 중심의 기능 위주라 큰 문제가 드러나지 않지만,
만약 사용자 정보를 수정하거나 게시글을 등록하는 등의 POST 요청이 늘어난다면 데이터가 꼬이거나 의도치 않은 결과가 발생할 수 있다.
추후 정보 수정, 삭제 API가 추가되면 설계 수정을 고려해봐야겠다.

<br/>

### 어려웠던 점

#### 1. static의 무분별한 사용

그룹 세션에서 인상 깊었던 토론 주제는 `static` 키워드의 사용 여부였다.  
단순한 유틸성 함수나 상수 관리 클래스에서는 `static`을 사용하는 것이 자연스러우나,
다른 객체와의 의존 관계나 상태를 가지는 클래스에는 부적절할 수 있다.

예를 들어, 예를 들어, 경준님의 코드에서는 유틸 클래스가 아니었음에도 static 메서드가 쓰이고 있었다.
객체가 한 번만 생성되면 충분하고, 다른 객체와도 상호작용하는 그런 클래스였다.
그렇다면 이런 클래스는 어떤 방식으로 관리하는 것이 좋을까?

1. **static 메서드 사용**
  - 장점: 객체 생성 없이 호출 가능. 메모리 절약.
  - 단점: 의존성 주입이 어렵고, 테스트나 확장성에서 불리함.

2. **일반 객체로 생성**
  - 장점: 명시적인 의존성 관리, 테스트 용이
  - 단점: 요청마다 객체를 새로 생성하면 성능 이슈 발생

3. **싱글톤 패턴 적용 (선택)**
  - 장점: 하나의 인스턴스를 공유하되 객체처럼 다룰 수 있어 확장성과 테스트 용이성 확보
  - 결론적으로, 상태가 없고 재사용 가능한 객체는 싱글톤으로 구성하는 것이 현재 서버 구조에 가장 적합하다고 판단!

결론적으로, 상태를 가지지 않고 재사용 가능한 객체는 싱글톤 패턴으로 구성하는 것이 현재 서버 구조에 가장 적합하다는 데 의견이 모였다.

이 결론에 도달하기까지 다 같이 약 1시간 동안 여러 예시를 들어가며 고민하고 토론했다.
나 역시 지금까지는 유틸 함수나 여러 곳에서 공유해야 하는 필드나 메서드에 static을 습관적으로 붙여왔지만,
이제는 그 사용 이유와 맥락을 더 잘 이해하게 되었다.

<br/>

#  2️⃣ 회고 (KPT)

### KEEP (잘한 점 / 유지하고 싶은 습관)

#### K1. 개발팀 회의에서 유의미한 결과를 도출했다.

회의할 때 가장 어려운 순간은, 오랫동안 이야기를 나눴는데도 결론이 나지 않을 때다.
그래서 오늘은 기획에서 나온 솔루션에 대해 어떤 기술적인 챌린지를 녹여볼 수 있을지 논의하는 회의를 진행하면서,
미리 어떤 이야기를 해보고 싶은지 정리한 회의록을 작성해 구조를 세워두었다.

이렇게 하니 다른 팀원들도 오늘 회의에서 어떤 대화를 나눌지 빠르게 파악할 수 있었고,
브레인스토밍 → 의견 좁히기 → 문서 정리 → 공유라는 흐름으로 회의를 진행하니
기획/디자인 팀에게 개발팀의 상황을 전달하는 과정도 훨씬 명확해졌다.


<br/>

### Problem (아쉬웠던 점 / 놓친 부분)

#### P1. 이번 주 가장 심각한 이슈: 회고록이 밀렸다

<br/>

### Try (다음에 시도할 것 / 개선 방향)

#### T1. 내일이 없는 일도 있다는 걸 상기하자

내가 회고록을 미루는 이유는 뭘까?
1. 글쓰기가 어렵다. 잘 써야 할 것 같은 부담이 있다.
2. 부담에 비해 출력물이 좋지 않다.
3. 계속 고친다.

요지는 부담이다. 그러니 시간이 오래 걸리고, 당연한 순서로 미완성 회고록이 쌓인다. 만족스럽게 끝맺음을 짓지 못하니 자꾸 이전 회고록을 뒤적인다.
그렇지만 데일리 회고록의 의미는 '오늘' 있었던 일에 대한 회고다. 다음에 쓴다는 것은 초등학교 여름 방학 동안 미뤄뒀던 일기 쓰기 만큼 의미가 없다...

이 회고록 미룸에 대해 좀 심각하게 생각하는 이유는, 이런 문제가 비단 글쓰기에서만 발생하는 것은 아니기 때문이다.
잘하고 싶어하는 일이면 자꾸만 뒤를 돌아본다. 그래도 다행인 것은 하던 일에 익숙해지면 속도가 빨라진다.

해결책이라고 말하기엔 정말 단순한 접근이긴 하지만,
결국 내가 느린 사람이란걸 인정하고 익숙해질 때 까진 시간을 들이는 게 최선의 해법인 것 같다.

오늘도 숙련도를 높이는덴 왕도가 없다는 걸 깨달으며.. (글쓰기든, 개발이든) 

<br/>

#  3️⃣ 학습 내용 정리

<br/>
